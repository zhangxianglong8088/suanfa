动态规划：
     套路

     定义dp数组
     初始化dp数组
     循环dp数组

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
连续递增子数组问题 加法+乘法
     1、53 连续子数组的最大和：（连续）
                       dp[i]:含义是0-i之间连续子数组的和
                       转移方程：dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);

     2、152 连续子数组的最大乘积：（连续）
                      dpMax[i] = Math.max(dpMax[i - 1] * nums[i], Math.max(dpMin[i - 1] * nums[i], nums[i]));
                      dpMin[i] = Math.min(dpMax[i - 1] * nums[i], Math.min(dpMin[i - 1] * nums[i], nums[i]));
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
（递增子序列和递增序列问题）求长度最大
     1、 674. 最长连续递增子数组：(连续) 递增子数组 通过一次for循环，
                        int[] dp = new int[n]; //dp数组的含义：以nums[i] 结尾的递增子数组的最大长度
                        状态转移方程：
                         for(int i = 1 ;i<n;i++){
                                  if(nums[i-1]<nums[i]){
                                      dp[i] = dp[i-1]+1;
                                  }else{
                                      dp[i] = 1;
                                  }
                             }

     2、 300. 最长递增子序列：（不连续）递增序列可以不连续，通过两次for循环，j指针赋值
         for (int i = 1; i < n; i++) {
                 int max = Integer.MIN_VALUE;
                 for (int j = 0; j < i; j++) {
                     if (nums[j] < nums[i]) {
                         max = Math.max(max, dp[j] + 1);
                         dp[i] = max;
                     }
                 }
             }

         *** 体会这里 为什么 dp[i] = max 不能放在第一层循环里面
---------------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------------
    公共子数组（连续+不连续）
     3、718.  最长的公共子数组：
          //初始化dp数组
             int result = 0;

             //遍历dp数组
             for (int i = 1; i <= nums1.length; i++) {
                 for (int j = 1; j <= nums2.length; j++) {
                     if (nums1[i - 1] == nums2[j - 1]) {
                         dp[i][j] = dp[i - 1][j - 1] + 1;
                         result = Math.max(result, dp[i][j]);
                     }
                 }
             }


     4、1143. 最长公共子序列：
              最长的公共子串：https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=117&tqId=37799&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D117&difficulty=undefined&judgeStatus=undefined&tags=&title=
           for (int i = 1; i <= n1; i++) {
            char t1 = text1.charAt(i - 1);
            for (int j = 1; j <= n2; j++) {
                char t2 = text2.charAt(j - 1);
                if (t1 == t2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }

            }
        }

*** 以上这两道题的区别在于 在两个值不相等的情况下，子数组不需要处理，但是子序列要处理（因为不连续）
---------------------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------------------
392. 判断子序列
判断 t是否是s的一个子序列


---------------------------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------------------------
     5、最长的回文子串 定义两个指针区间 看i到j之间是不是回文字符串
         dp数组的含义是从j到i之间是否是回文子串

         for (int i = 0; i < n; i++) {
                //思考：为什么j和i都是从0开始
                for (int j = 0; j <= i; j++) {
                    if (s.charAt(i) == s.charAt(j)) {
                        if (i - j <= 2) {
                            dp[i][j] = true;
                        } else {
                            dp[i][j] = dp[i - 1][j + 1];
                        }
                    }
                }
            }



     516、最长的回文子序列
---------------------------------------------------------------------------------------------------------------------------------